// Code generated by MockGen. DO NOT EDIT.
// Source: service.go
//
// Generated by this command:
//
//	mockgen -source=service.go -destination=mocks/mock_dependencies.go -package=mocks RabbitMQProducerInterface,TelegramClientInterface,RedisClientInterface
//

// Package mocks is a generated GoMock package.
package mocks

import (
	models "DelayedNotifier/internal/models"
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockNotificationRepositoryInterface is a mock of NotificationRepositoryInterface interface.
type MockNotificationRepositoryInterface struct {
	ctrl     *gomock.Controller
	recorder *MockNotificationRepositoryInterfaceMockRecorder
	isgomock struct{}
}

// MockNotificationRepositoryInterfaceMockRecorder is the mock recorder for MockNotificationRepositoryInterface.
type MockNotificationRepositoryInterfaceMockRecorder struct {
	mock *MockNotificationRepositoryInterface
}

// NewMockNotificationRepositoryInterface creates a new mock instance.
func NewMockNotificationRepositoryInterface(ctrl *gomock.Controller) *MockNotificationRepositoryInterface {
	mock := &MockNotificationRepositoryInterface{ctrl: ctrl}
	mock.recorder = &MockNotificationRepositoryInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNotificationRepositoryInterface) EXPECT() *MockNotificationRepositoryInterfaceMockRecorder {
	return m.recorder
}

// CreateNotification mocks base method.
func (m *MockNotificationRepositoryInterface) CreateNotification(notification *models.Notification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNotification", notification)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MockNotificationRepositoryInterfaceMockRecorder) CreateNotification(notification any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*MockNotificationRepositoryInterface)(nil).CreateNotification), notification)
}

// DeleteNotification mocks base method.
func (m *MockNotificationRepositoryInterface) DeleteNotification(id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteNotification", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteNotification indicates an expected call of DeleteNotification.
func (mr *MockNotificationRepositoryInterfaceMockRecorder) DeleteNotification(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteNotification", reflect.TypeOf((*MockNotificationRepositoryInterface)(nil).DeleteNotification), id)
}

// GetAllNotifications mocks base method.
func (m *MockNotificationRepositoryInterface) GetAllNotifications() ([]*models.Notification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAllNotifications")
	ret0, _ := ret[0].([]*models.Notification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAllNotifications indicates an expected call of GetAllNotifications.
func (mr *MockNotificationRepositoryInterfaceMockRecorder) GetAllNotifications() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAllNotifications", reflect.TypeOf((*MockNotificationRepositoryInterface)(nil).GetAllNotifications))
}

// GetNotificationStatus mocks base method.
func (m *MockNotificationRepositoryInterface) GetNotificationStatus(id string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNotificationStatus", id)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNotificationStatus indicates an expected call of GetNotificationStatus.
func (mr *MockNotificationRepositoryInterfaceMockRecorder) GetNotificationStatus(id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNotificationStatus", reflect.TypeOf((*MockNotificationRepositoryInterface)(nil).GetNotificationStatus), id)
}

// UpdateNotificationStatus mocks base method.
func (m *MockNotificationRepositoryInterface) UpdateNotificationStatus(id, status string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateNotificationStatus", id, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateNotificationStatus indicates an expected call of UpdateNotificationStatus.
func (mr *MockNotificationRepositoryInterfaceMockRecorder) UpdateNotificationStatus(id, status any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateNotificationStatus", reflect.TypeOf((*MockNotificationRepositoryInterface)(nil).UpdateNotificationStatus), id, status)
}

// MockRabbitMQProducerInterface is a mock of RabbitMQProducerInterface interface.
type MockRabbitMQProducerInterface struct {
	ctrl     *gomock.Controller
	recorder *MockRabbitMQProducerInterfaceMockRecorder
	isgomock struct{}
}

// MockRabbitMQProducerInterfaceMockRecorder is the mock recorder for MockRabbitMQProducerInterface.
type MockRabbitMQProducerInterfaceMockRecorder struct {
	mock *MockRabbitMQProducerInterface
}

// NewMockRabbitMQProducerInterface creates a new mock instance.
func NewMockRabbitMQProducerInterface(ctrl *gomock.Controller) *MockRabbitMQProducerInterface {
	mock := &MockRabbitMQProducerInterface{ctrl: ctrl}
	mock.recorder = &MockRabbitMQProducerInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRabbitMQProducerInterface) EXPECT() *MockRabbitMQProducerInterfaceMockRecorder {
	return m.recorder
}

// Publish mocks base method.
func (m *MockRabbitMQProducerInterface) Publish(data []byte, ctx context.Context, routingKey string, delay time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", data, ctx, routingKey, delay)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockRabbitMQProducerInterfaceMockRecorder) Publish(data, ctx, routingKey, delay any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockRabbitMQProducerInterface)(nil).Publish), data, ctx, routingKey, delay)
}

// MockTelegramClientInterface is a mock of TelegramClientInterface interface.
type MockTelegramClientInterface struct {
	ctrl     *gomock.Controller
	recorder *MockTelegramClientInterfaceMockRecorder
	isgomock struct{}
}

// MockTelegramClientInterfaceMockRecorder is the mock recorder for MockTelegramClientInterface.
type MockTelegramClientInterfaceMockRecorder struct {
	mock *MockTelegramClientInterface
}

// NewMockTelegramClientInterface creates a new mock instance.
func NewMockTelegramClientInterface(ctrl *gomock.Controller) *MockTelegramClientInterface {
	mock := &MockTelegramClientInterface{ctrl: ctrl}
	mock.recorder = &MockTelegramClientInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTelegramClientInterface) EXPECT() *MockTelegramClientInterfaceMockRecorder {
	return m.recorder
}

// SendMessage mocks base method.
func (m *MockTelegramClientInterface) SendMessage(chatID int64, text string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMessage", chatID, text)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendMessage indicates an expected call of SendMessage.
func (mr *MockTelegramClientInterfaceMockRecorder) SendMessage(chatID, text any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMessage", reflect.TypeOf((*MockTelegramClientInterface)(nil).SendMessage), chatID, text)
}

// MockRedisClientInterface is a mock of RedisClientInterface interface.
type MockRedisClientInterface struct {
	ctrl     *gomock.Controller
	recorder *MockRedisClientInterfaceMockRecorder
	isgomock struct{}
}

// MockRedisClientInterfaceMockRecorder is the mock recorder for MockRedisClientInterface.
type MockRedisClientInterfaceMockRecorder struct {
	mock *MockRedisClientInterface
}

// NewMockRedisClientInterface creates a new mock instance.
func NewMockRedisClientInterface(ctrl *gomock.Controller) *MockRedisClientInterface {
	mock := &MockRedisClientInterface{ctrl: ctrl}
	mock.recorder = &MockRedisClientInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisClientInterface) EXPECT() *MockRedisClientInterfaceMockRecorder {
	return m.recorder
}

// Del mocks base method.
func (m *MockRedisClientInterface) Del(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockRedisClientInterfaceMockRecorder) Del(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockRedisClientInterface)(nil).Del), ctx, key)
}

// Get mocks base method.
func (m *MockRedisClientInterface) Get(ctx context.Context, key string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockRedisClientInterfaceMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRedisClientInterface)(nil).Get), ctx, key)
}

// SetWithExpiration mocks base method.
func (m *MockRedisClientInterface) SetWithExpiration(ctx context.Context, key string, value any, expiration time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetWithExpiration", ctx, key, value, expiration)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetWithExpiration indicates an expected call of SetWithExpiration.
func (mr *MockRedisClientInterfaceMockRecorder) SetWithExpiration(ctx, key, value, expiration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetWithExpiration", reflect.TypeOf((*MockRedisClientInterface)(nil).SetWithExpiration), ctx, key, value, expiration)
}
